进程相关概念



## 1.进程与线程

1.进程

- 进程：进程是正在执行程序的实例，是资源分配最小的单位，每个进程都有自己单独的资源区域。进程在一定的环境下，把静态的程序代码运行起来，通过使用不同的资源，来完成一定的任务。进程的环境包括环境变量，进程所掌控的资源，有中央处理器，有内存，打开的文件，映射的网络端口等。

- 守护进程：运行在后台的进程，用于执行特定的系统任务。

- 进程的状态：只介绍进程基本状态。

- - 就绪态：进程已分配到除CPU以外的所有必要资源后，只要再获得CPU，便可立即执行，进程这时的状态称为就绪状态。在一个系统中处于就绪状态的进程可能有多个，通常将它们排成一个队列，称为就绪队列。
  - 运行态：进程已获得CPU，其程序正在执行。
  - 阻塞态：正在执行的进程由于发生某事件而暂时无法继续执行时，便放弃处理机而处于暂停状态。致使进程阻塞的典型事件有：请求I/O，申请缓冲空间等。通常将这种处于阻塞状态的进程也排成一个队列。阻塞状态的进程，除非某种外部时间发生，否则进程不能运行。

- 进程状态的转换：进程在运行期间，不断地从一种状态转换到另一种状态，它可以多次处于就绪状态和运行状态，也可以多次处于阻塞状态。

- - 就绪→运行：处于就绪状态的进程，当进程调度程序为之分配了处理机后，该进程便由就绪状态转变成运行状态。
  - 运行→就绪：处于运行状态的进程在其运行过程中，因分配给它的一个时间片已用完而不得不让出处理机，于是进程从运行状态转变成就绪状态。
  - 运行→阻塞：正在运行的进程因等待某种事件发生而无法继续运行时，便从运行状态变成阻塞状态。
  - 阻塞→就绪：处于阻塞状态的进程，若其等待的事件已经发生，于是进程由阻塞状态转变为就绪状态。

- 进程表：为实现进程模型，每个进程占用一个进程表项，该进程表项包含了进程状态的重要信息，包括程序计数器、堆栈指针、内存分配状况、所打开文件的状态、帐号和调度信息等。

2.线程

- 线程：cpu调度的最小单位。线程共享进程的资源，多个线程可以共享同一地址空间和其他资源，比如共享全局变量。线程作为进程的一部分，扮演的角色就是怎么利用中央处理器去运行代码。线程关注的是中央处理器的运行，而不是内存等资源的管理。同一时刻只有一个线程占用cpu，但高速切换给人带来并行的假象。

- 线程状态及转换：只介绍线程基本状态。

- - 就绪状态：线程对象被创建后，其它线程调用了该对象的start()方法，从而来启动该线程。处于就绪状态的线程，随时可能被CPU调度执行。
  - 运行状态: 线程已获得CPU，正在运行。
  - 阻塞状态： 阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。

- 为什么多线程？

- - 线程比进程更加轻量级，线程更容易、快捷的创建和销毁。
  - 多CPU系统中，使用线程提高CPU利用率。
  - 耗时的操作使用线程，提高应用程序响应。拥有多个线程允许活动彼此重叠进行，从而会加快应用程序执行速度。
  - 并行操作时使用线程，如C/S架构的服务器端并发线程响应用户的请求。
  - 改善程序结构。一个既长又复杂的进程可以考虑分为多个线程，成为几个独立或半独立的运行部分，这样的程序会利于理解和修改。
  - 并行实体共享同一个地址空间和所有可用数据的能力。



**孤儿进程：**

指的是,父进程先结束 ,而子进程还在运行着,

孤儿进程无害,有其存在的必要性

例如:qq开启了浏览器,qq先退出了 浏览器应该继续运行

孤儿进程会被操作系统接管

**僵尸进程：**

 指得是,子进程已经结束了,但是操作系统会保存一些进程信息,如PID,运行时间等,此时这个进程就称之为僵尸进程

僵尸进程如果太多将会占用大量的资源,造成系统无法开启新新进程

linux 中有一个wai/waitpid 用于父进程回收子进程资源 

python会自动回收僵尸进程



## 2.进程与程序的区别

程序就是一堆计算机可以识别文件,程序在没有被运行就是躺在硬盘上的一堆二进制，运行程序时,要从硬盘读取数据到内存中,CPU从内存读取指令并执行 ,一旦运行就产生了进程。

一个程序可以多次执行 产生多个进程,但是进程之间相互独立

当我们右键运行了一个py文件时 ,其实启动的是python解释器,你的py文件其实是当作参数传给了解释器。



- 调度：在引入线程的操作系统中，线程是调度和分配的基本单位 ，进程是资源拥有的基本单位 。把传统进程的两个属性分开，线程便能轻装运行，从而可显著地提高系统的并发程度。 在同一进程中，线程的切换不会引起进程的切换，在由一个进程中的线程切换到另一个进程中的线程时，才会引起进程的切换。
- 并发性：在引入线程的操作系统中，不仅进程之间可以并发执行，而且在一个进程中的多个线程之间亦可并发执行，因而使操作系统具有更好的并发性，从而能更有效地使用系统资源和提高系统吞吐量。
- 拥有资源：进程是资源分配的最小单位，线程是cpu调度的最小单位。进程更倾向于内存管理的概念，进程在自己的区域掌控自己的资源，也不越界。线程更倾向于cpu的运行。进程在执行过程中拥有独立的内存单元，而多个线程共享内存， 从而极大的提高了程序的运行效率。
- 系统开销：由于在创建或撤消进程时，系统都要为之分配或回收资源，因此，操作系统所付出的开销将显著地大于在创建或撤消线程时的开销。 进程切换的开销也远大于线程切换的开销。
- 进程更为健壮。一个进程之间的某个线程死掉，整个进程就死掉了。一个进程死掉对其他进程没有影响。另外一个线程可以创建和撤销另一个线程。同一个进程中的多个线程之间可以并发执行。



## 3.程序运行的三种状态

1. 阻塞与非阻塞

　　阻塞：当程序遇到IO操作(输入输出)时，就进入了阻塞状态

　　非阻塞：程序正常运行种，没有遇到任何IO操作，就处于非阻塞状态

2. 并发

　　同一时间段，有多个程序都处于运行状态，但一个时间点只有一个程序被CUP处理，本质上切换执行，切换的同时，保存上一个任务的操作

3. 并行

   同一时间段，多个任务同时被CUP处理

并发与并行很好理解，几队人去排队买coffee,并发就是只有一个咖啡机，同一时间只能处理一个队的订单；并行则是有多个咖啡机，同一时间可以处理若干个队的订单。



**阻塞与非阻塞说的是程序运行状态，并发与并行说的是任务的处理方式**



> 提高效率的根本方法就是让程序尽可能处于运行状态，减少IO 尽可能多占用CPU时间，缓冲区就是用于减少IO操作的



## 4.锁

通过锁机制，能够保证在多核多线程环境中，在某一个时间点上，只能有一个线程进入临界区代码，从而保证临界区中操作数据的一致性。

所谓的锁，可以理解为内存中的一个整型数，拥有两种状态：空闲状态和上锁状态。加锁时，判断锁是否空闲，如果空闲，修改为上锁状态，返回成功。如果已经上锁，则返回失败。解锁时，则把锁状态修改为空闲状态。

### 4.2 死锁的概念

死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。死锁的原因包括系统资源不足、进程运行推进顺序不合适、资源分配不当等。

比如两只羊过独木桥。进程比作羊，资源比作桥。若两只羊互不相让，争着过桥，就产生死锁。

### 4.3 死锁的必要条件

产生死锁的四个必要条件： + 互斥条件：一个资源每次只能被一个进程使用。 + 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。 + 不剥夺条件： 进程已获得的资源，在末使用完之前，不能强行剥夺。 + 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。存在一个进程等待序列{P1，P2，…，Pn}，其中P1等待P2所占有的某一资源，P2等待P3所占有的某一资源，……，而Pn等待P1所占有的的某一资源，形成一个进程循环等待环。

### 4.4 解决死锁的四个方式

- 鸵鸟算法。(直接忽略该问题)
- 检测死锁并且恢复。（检测与解除策略）
- 仔细地对资源进行动态分配，以避免死锁。（避免策略）
- 通过破除死锁四个必要条件之一，来防止死锁产生。（预防策略）



## 5.多线程

在多线程环境中，会涉及到线程之间的通信，就容易碰到同步非阻塞，异步非阻塞，同步阻塞，异步阻塞这类问题。这里的同步与异步是什么意思？

这个概念要比较与阻塞与非阻塞。阻塞与非阻塞说的是通信的发起方，同步和异步说的是接收方。

比如这样一个场景，A是发起方，B是接收方：

A给B打电话，A一直等待B接听，B接电话后A才能说明消息这就是阻塞；A直接开启免提后不管B是否接听去做其他事情，等B接听后告诉他消息，这就是非阻塞。阻塞与非阻塞说的是A的行为

B接到电话铃声(信号)后，选择立马接听电话，这就是同步；或者不能受电话，回一条短信才有空，这就是异步的方式。同步和异步说的是B的行为。

我们需要根据实际需要，来指定我们的程序怎么进行通信，